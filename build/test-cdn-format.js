window.storyFormat({"name":"TwineSpace","version":"1.0.5","source":"<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n\t\t<title>{{STORY_NAME}}</title>\n\t\t<style>body {\n    font-size: 2em;\n}\n\ntw-link, a {\n    color: blue;\n    cursor: pointer;\n    text-decoration: underline;\n}\n\na-scene {\n    position: absolute;\n    top: 0;\n    left: 0;\n    transition: opacity ease 2s;\n    z-index: 999;\n    height: 80%;\n}\n\ntw-story {\n   background: transparent; \n   pointer-events: none;\n   padding: 0;\n   color: white;\n   z-index: 1;\n   height: 20%;\n}\n\ntw-passage {\n    background: black;\n    border: 6px double white;\n    font-size: 1em;\n    line-height: 1em;\n    margin: auto 2vw 2em 2vw;\n    pointer-events: auto;\n    overflow: auto;\n    padding: 1vw;\n    color: white;\n    z-index: 1;\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    max-height: 40vh;\n    width: calc(100vw - 12px - 6vw);\n}\n  \n.centered {\n    position: fixed;\n    bottom: 0%;\n    left: 0%;\n    width: 100vw; \n    transform: translate(0%, 0%);\n    z-index: 1000;\n}\n  \n.arjs-loader {\n    height: 50%;\n    width: 50%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    background-color: rgba(0, 0, 0, 0.8);\n    z-index: 9999;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n  \n.arjs-loader div {\n    text-align: center;\n    font-size: 1.25em;\n    color: white;\n}\n  </style>\n\t\t\n\t</head>\n\t<body>\n\t\t<tw-story class=\"centered\">\n\t\t\t<tw-passage class=\"passage\" aria-live=\"polite\"></tw-passage>\n\t\t</tw-story>\n\t\t{{STORY_DATA}}\n\t\t<script src=\"/vendor/jquery.min.js\"></script>\n<script src=\"/vendor/aframe.min.js\"></script>\n<script src=\"/vendor/markdown-it.min.js\"></script>\n<script src=\"/vendor/lodash.min.js\"></script>\n<script>\n\n// Require jQuery\nconst $ = require('jquery');\n\n/**\n * A proxy between AFrame (which uses elements and attributes)\n * and our macros.\n * @class AFrameProxy\n */\nclass AFrameProxy {\n  /**\n   * Create an a-scene element if one does not exist.\n   * @function createScene\n   * @returns {Element} Current `<a-scene>` element\n   * @static\n   */\n  static createScene () {\n    // As this might be called multiple times,\n    //  we need to test to see if the <a-scene>\n    //  element already exists before we add\n    //  another one to the document.\n    if ($('a-scene').length === 0) {\n      // Add the a-scene element to the body.\n      $(document.body).append($('<a-scene vr-mode-ui=\"enabled: false\" arjs=\"debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;\" />'));\n    }\n\n    // Return either current `<a-scene>` or\n    //  one just created.\n    return $('a-scene');\n  }\n\n  /**\n   * Adds an a-element child to an element.\n   * @function add\n   * @param {Element} parent Where child should be appended.\n   * @param {string} entity AFrame element to append.\n   * @param {string} attributes Element attributes.\n   * @returns {Element} Created element.\n   * @static\n   */\n  static add (parent, entity, attributes) {\n    // Look for parent element.\n    const parentElement = $(parent);\n\n    // Does it exist?\n    if (parentElement.length === 0) {\n      // Passage does not exist.\n      // Throw error.\n      throw new Error('Parent element does not exist!');\n    }\n\n    // Create element based on entity name.\n    const entityElement = $(`<a-${entity} ${attributes} />`);\n    parent.append(entityElement);\n    return entityElement;\n  }\n\n  /**\n   * Removes the current a-scene element.\n   * @function removeScene\n   * @static\n   */\n  static removeScene () {\n    $('a-scene').remove();\n  }\n}\n\nmodule.exports = AFrameProxy;\n\n\n/**\n * @class Passage\n */\n\nclass Passage {\n  constructor (name = 'Default', tags = [], source = '') {\n    /**\n     * @property {string} name - The name of passage\n     * @type {string}\n     */\n\n    this.name = name;\n\n    /**\n     * @property {Array} tags - The tags of the passage.\n     * @type {Array}\n     */\n\n    this.tags = tags;\n\n    /**\n     * @property {string} source - The passage source code.\n     * @type {string}\n     */\n\n    this.source = source;\n  }\n}\n\nmodule.exports = Passage;\n\n\n// Require AFrameProxy\nconst AFrameProxy = require('./AFrameProxy.js');\nconst $ = require('jquery');\nconst markdown = require('markdown-it')({\n  html: true,\n  linkify: true,\n  typographer: true\n}); ;\n\n/**\n * Rules for un-escaping and parsing author content from passages\n * into visual effects and content for readers.\n * @class Markdown\n */\nclass Markdown {\n  /**\n   * Parse text. Convert authored markdown symbols into\n   * visual effects and content for readers.\n   * @function parse\n   * @param {string} text - Text to parse.\n   * @returns {string} Parsed text.\n   * @static\n   */\n  static parse (text) {\n    // Remove any a-scene elements, if they exist.\n    AFrameProxy.removeScene();\n\n    const rules = [\n      // [[rename|destination]]\n      [/\\[\\[(.*?)\\|(.*?)\\]\\]/g, '<tw-link role=\"link\" data-passage=\"$2\">$1</tw-link>'],\n      // [[rename->dest]]\n      [/\\[\\[(.*?)->(.*?)\\]\\]/g, '<tw-link role=\"link\" data-passage=\"$2\">$1</tw-link>'],\n      // [[dest<-rename]]\n      [/\\[\\[(.*?)<-(.*?)\\]\\]/g, '<tw-link role=\"link\" data-passage=\"$1\">$2</tw-link>'],\n      // [[destination]]\n      [/\\[\\[(.*?)\\]\\]/g, '<tw-link role=\"link\" data-passage=\"$1\">$1</tw-link>'],\n      // Look for (entity:attributes)[children]\n      [/\\((.*?):([^>]*?)\\)\\[([^>]*?)\\]/gmi, (match, entity, attributes, children) => {\n        const rootParent = AFrameProxy.createScene();\n        const parentElement = AFrameProxy.add(rootParent, entity, attributes);\n        children.replace(/\\((.*?):([^>]*?)\\)/gmi, (match, entity, attributes) => {\n          AFrameProxy.add(parentElement, entity, attributes);\n          return '';\n        });\n        return '';\n      }],\n      // Look for (entity:attributes)\n      [/\\((.*?):([^>]*?)\\)/gmi, (match, entity, attributes) => {\n        // Test for embed-scene.\n        if (entity.toLowerCase() === 'embed-scene') {\n          // Trim whitespace.\n          const trimmedName = attributes.trim();\n          // Slice off quotation marks.\n          const quoteName = trimmedName.slice(1, trimmedName.length - 1);\n          // Attempt to get source.\n          const passageSource = window.story.include(quoteName);\n          // Append to body.\n          $(document.body).append(passageSource);\n          // Return empty string.\n          return '';\n        } else {\n          const rootParent = AFrameProxy.createScene();\n          AFrameProxy.add(rootParent, entity, attributes);\n          return '';\n        }\n      }],\n      // Break Rule\n      [/[\\r\\n\\n]/g, '<br>']\n    ];\n\n    rules.forEach(([rule, template]) => {\n      text = text.replace(rule, template);\n    });\n\n    // Silly, but if there is a marker, we need a camera.\n    if ($('a-marker').length > 0) {\n      // Add a camera.\n      $('a-scene').add('<a-entity camera>');\n    }\n\n    // Return Markdown rendered text.\n    return markdown.renderInline(text);\n  }\n\n  /**\n   * Unescape content.\n   * @function unescape\n   * @param {string} text - Text to unescape\n   * @returns {string} - Unescaped text\n   * @static\n   */\n  static unescape (text) {\n    const unescapeSequences = [\n      ['&amp;', '&'],\n      ['&lt;', '<'],\n      ['&gt;', '>'],\n      ['&quot;', '\"'],\n      ['&#x27;', \"'\"],\n      ['&#x60;', '`']\n    ];\n\n    unescapeSequences.forEach(([rule, template]) => {\n      text = text.replaceAll(rule, template);\n    });\n\n    return text;\n  }\n}\n\nmodule.exports = Markdown;\n\n\n/**\n * @external Element\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Element}\n */\nconst $ = require('jquery');\nconst ejs = require('ejs');\nconst Passage = require('./Passage.js');\nconst Markdown = require('./Markdown.js');\n\n/**\n * An object representing the entire story. After the document has completed\n * loading, an instance of this class will be available at `window.story`.\n * @class Story\n */\nclass Story {\n  constructor () {\n    /**\n     * @property {Element} storyDataElement - Reference to tw-storydata element\n     * @type {Element}\n     * @readonly\n     */\n    this.storyDataElement = $('tw-storydata');\n\n    /**\n     * @property {string} name - The name of the story.\n     * @type {string}\n     * @readonly\n     */\n    this.name = this.storyDataElement.attr('name');\n\n    /**\n     * @property {string} creator - The program that created this story.\n     * @type {string}\n     * @readonly\n     */\n    this.creator = this.storyDataElement.attr('creator');\n\n    /**\n     * @property {string} creatorVersion - The version of the program used to create this story.\n     * @type {string}\n     * @readonly\n     */\n    this.creatorVersion = this.storyDataElement.attr('creator-version');\n\n    /**\n     * An array of all passages, indexed by ID.\n     * @property {Array} passages - Passages array\n     * @type {Array}\n     */\n    this.passages = [];\n\n    // For each child element of the tw-storydata element,\n    //  create a new Passage object based on its attributes.\n    this.storyDataElement.children('tw-passagedata').each((index, element) => {\n      const elementReference = $(element);\n      let tags = elementReference.attr('tags');\n\n      // Does the 'tags' attribute exist?\n      if (tags !== '' && tags !== undefined) {\n        // Attempt to split by space\n        tags = tags.split(' ');\n      } else {\n        // It did not exist, so we create it as an empty array.\n        tags = [];\n      }\n\n      // Push the new passage.\n      this.passages.push(new Passage(\n        elementReference.attr('name'),\n        tags,\n        Markdown.unescape(elementReference.html())\n      ));\n    });\n\n    /**\n     * An array of user-specific scripts to run when the story is begun.\n     * @property {Array} userScripts - Array of user-added JavaScript.\n     * @type {Array}\n     */\n    this.userScripts = [];\n\n    // Add the internal (HTML) contents of all SCRIPT tags\n    $('*[type=\"text/twine-javascript\"]').each((index, value) => {\n      this.userScripts.push($(value).html());\n    });\n\n    /**\n     * An array of user-specific style declarations to add when the story is\n     * begun.\n     * @property {Array} userStyles - Array of user-added styles.\n     * @type {Array}\n     */\n    this.userStyles = [];\n\n    // Add the internal (HTML) contents of all STYLE tags\n    $('*[type=\"text/twine-css\"]').each((index, value) => {\n      this.userStyles.push($(value).html());\n    });\n\n    /**\n     * Story element.\n     * @property {Element} storyElement - Story element.\n     * @type {Element}\n     * @readonly\n     */\n    this.storyElement = $('tw-story');\n\n    // Catch user clicking on links.\n    this.storyElement.on('click', 'tw-link[data-passage]', (e) => {\n      // Pull destination passage name from the attribute.\n      const passageName = Markdown.unescape($(e.target).closest('[data-passage]').data('passage'));\n      // Show the passage by name.\n      this.show(passageName);\n    });\n\n    /**\n     * Passage element.\n     * @property {Element} passageElement - Passage element.\n     * @type {Element}\n     */\n    this.passageElement = $('tw-passage');\n  }\n\n  /**\n   * Returns the source of a passage by name.\n   * @function include\n   * @param {string} name Name of the passage.\n   * @returns {string} Passage source.\n   */\n  include (name) {\n    const passage = this.getPassageByName(name);\n\n    if (passage === null) {\n      throw new Error('Passage does not exist!');\n    }\n\n    return passage.source;\n  }\n\n  /**\n   * Begins playing this story based on data from tw-storydata.\n   * @function start\n   */\n  start () {\n    // For each style, add them to the body as extra style elements.\n    this.userStyles.forEach((style) => {\n      $(document.body).append(`<style>${style}</style>`);\n    });\n\n    // For each script, run them.\n    this.userScripts.forEach((script) => {\n      try {\n        ejs.render(`<%${script}%>`, { $ });\n      } catch (error) {\n        throw new Error(`User script error: ${error}`);\n      }\n    });\n\n    // Look for passages with 'script' tag.\n    const scriptPassages = this.getPassagesByTag('script');\n\n    // For each script, run them.\n    scriptPassages.forEach((script) => {\n      try {\n        ejs.render(`<%${script.source}%>`, { $ });\n      } catch (error) {\n        throw new Error(`User script error: ${error}`);\n      }\n    });\n\n    // Get the startnode value (which is a number).\n    const startingPassageID = parseInt(this.storyDataElement.attr('startnode'));\n\n    // Try to find the starting passage\n    const startingPassageElement = $(`[pid=\"${startingPassageID}\"]`);\n\n    // Was it found?\n    if (startingPassageElement.length === 0) {\n      // Was not found, throw error.\n      throw new Error('Starting passage not found!');\n    }\n\n    // If the 'name' attribute does not exist,\n    //  show() will be passed undefined\n    //  and throw an error.\n    this.show(startingPassageElement.attr('name'));\n  }\n\n  /**\n   * Replaces current passage shown to reader with rendered source of named passage.\n   * If the named passage does not exist, an error is thrown.\n   * @function show\n   * @param {string} name - name of the passage.\n   */\n  show (name) {\n    // Attempt to find passage.\n    const passage = this.getPassageByName(name);\n\n    // Does passage exist?\n    if (passage === null) {\n      // Passage was not found.\n      // Throw error.\n      throw new Error(`There is no passage with the name ${name}`);\n    }\n\n    // Overwrite current tags.\n    this.passageElement.attr('tags', passage.tags);\n\n    // Use Snowman approach to pre-processing.\n    try {\n      passage.source = ejs.render(passage.source, { $ }, { outputFunctionName: 'echo' });\n    } catch (error) {\n      throw new Error(`User script error: ${error}`);\n    }\n\n    // Overwrite the parsed with the rendered.\n    this.passageElement.html(Markdown.parse(passage.source));\n  }\n\n  /**\n   * Returns an array of none, one, or many passages matching a specific tag.\n   * @function getPassagesByTag\n   * @param {string} tag - Tag to search for.\n   * @returns {Array} Array containing none, one, or many passage objects.\n   */\n  getPassagesByTag (tag) {\n    // Search internal passages\n    return this.passages.filter((p) => {\n      return p.tags.includes(tag);\n    });\n  }\n\n  /**\n   * Returns a Passage object by name from internal collection. If none exists, returns null.\n   * The Twine editor prevents multiple passages from having the same name, so\n   * this always returns the first search result.\n   * @function getPassageByName\n   * @param {string} name - name of the passage.\n   * @returns {Passage|null} Passage object or null.\n   */\n  getPassageByName (name) {\n    // Create default value\n    let passage = null;\n\n    // Search for any passages with the name\n    const result = this.passages.filter((p) => p.name === name);\n\n    // Were any found?\n    if (result.length !== 0) {\n      // Grab the first result.\n      passage = result[0];\n    }\n\n    // Return either null or first result found.\n    return passage;\n  }\n}\n\nmodule.exports = Story;\n\n\n// Initialize\nwindow.$ = $;\nconsole.log('Initializing complete story system...');\nwindow.story = new Story();\nconsole.log('Story object created, starting story...');\nwindow.story.start();\nconsole.log('Story started successfully');\n\n</script>\n\t</body>\n</html>","description":"Twine 2 story format supporting locative and mixed reality projects. See its <a href='https://videlais.github.io/twine-space/#/' target='_blank' rel='noopener noreferrer'>documentation</a>","proofing":false,"license":"MIT","image":"icon.svg","author":"Dan Cox, PS Berge, and Jack Murray"});